#include <iostream>
#include <stdexcept>
#include <sstream>

std::string 
RunLengthEncodingEncode(const std::string& input) 
{
    if (input.empty()) return "";

    std::ostringstream encoded;
    int length = input.length();

    for (int i = 0; i < length; ++i) {
        char currentChar = input[i];
        int count = 1;

        while (i + 1 < length && input[i] == input[i + 1]) {
            ++count;
            ++i;
        }

        encoded << currentChar << count;
    }

    return encoded.str();
}

std::string 
RunLengthEncodingDecode(const std::string& input) 
{
    if (input.empty()) return "";

    std::ostringstream decoded;
    int length = input.length();

    for (int i = 0; i < length; ++i) {
        char character = input[i];

        if (i + 1 >= length || !isdigit(input[i + 1])) {
            throw std::invalid_argument("Invalid encoded input: Missing or incorrect count value.");
        }

        int count = 0;
        while (i + 1 < length && isdigit(input[i + 1])) {
            count = count * 10 + (input[++i] - '0');
        }

        decoded << std::string(count, character);
    }

    return decoded.str();
}

std::string 
ParzpoxarinumEncrypt(const std::string& text, const std::string& key) 
{
    if (text.length() != key.length()) {
        throw std::invalid_argument("Error: The key must be the same length as the message for One-Time Pad cipher.");
    }

    std::string result;
    for (size_t i = 0; i < text.length(); ++i) {
        char textChar = std::toupper(text[i]);
        char keyChar = std::toupper(key[i]);

        if (std::isalpha(textChar) && std::isalpha(keyChar)) {
            char encryptedChar = ((textChar - 'A') + (keyChar - 'A')) % 26 + 'A';
            result += encryptedChar;
        } else {
            result += textChar;
        }
    }
    return result;
}

std::string
ParzpoxarinumDecrypt(const std::string& text, const std::string& key) 
{
    if (text.length() != key.length()) {
        throw std::invalid_argument("Error: The key must be the same length as the message for One-Time Pad cipher.");
    }

    std::string result;
    for (size_t i = 0; i < text.length(); ++i) {
        char textChar = std::toupper(text[i]);
        char keyChar = std::toupper(key[i]);

        if (std::isalpha(textChar) && std::isalpha(keyChar)) {
            char decryptedChar = ((textChar - 'A') - (keyChar - 'A') + 26) % 26 + 'A';
            result += decryptedChar;
        } else {
            result += textChar;
        }
    }
    return result;
}

std::string
mixEncrypt(const std::string& text, const std::string& key)
{
    std::string result;
    result = ParzpoxarinumEncrypt(text, key);
    result = RunLengthEncodingEncode(result);
    std::cout << result << std::endl;
    result = RunLengthEncodingDecode(result);
    result = ParzpoxarinumDecrypt(result, key);
    std::cout << result << std::endl;
    return result;
}

int 
main()
{
    std::string text = "barev bolorin";
    std::string key =  "ashakertnerik";
    mixEncrypt(text, key);
    return 0;    
}


